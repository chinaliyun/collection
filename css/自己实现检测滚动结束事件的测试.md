目标
-
在移动端场景下，需要按需加载的功能，最常见的是一个列表页面，当用户滑动事件结束，并且页面滚动结束的时候，判断用户看到的位置是不是已经在列表的最后一项，这个时候就加载更多的列表项

尝试
-
window.onscroll事件只能检测滚动条的变化，不能检测到滚动结束事件，因此需要自己写一个模拟的页面滚动来实现目标

预想
-
想要实现这个目标，首先要考虑通过什么方法能够检测到滚动的结束事件，这里有两个方法

1. jquery的animate事件可以在animate结束后，通过回调函数来检查是否需要按需加载。以这个为例，可以想到通过写一个类似于jquery-animate事件的方法，来改变子元素的top值，最终实现目标

2. CSS3出现之后，JS可以通过transitioned、animationed监测到元素的过渡事件和动画事件的结束时间 

选择方法
-
不管是哪种方法，都可以实现监测结束的过程，但其中有一点事CSS3的优势：  动画贝塞尔曲线。 这是很重要的一点，如果使用方法1， 自己还要去写一套动画贝塞尔曲线的方法，无疑是很麻烦的，而CSS3自身就带有控制timing-function的属性，减少了很多工作。因此我决定使用方法2来实现这个目标

实现预想
-
1. 动画主要通过CSS3 - transform的translate属性实现
2. 页面的滑动主要分为两种： 惯性滑动和非惯性滑动；其中惯性滑动值得是：页面滑动距离和速度，根据用户滑动的距离和速度，页面滚动的距离和速度也不一样，非惯性滑动值得是：根据用户手指移动距离，页面滚动相应距离。

禁用浏览器自带的滑动事件
-
事先我已经对html、body设置了宽高都为100%的样式，并且overflow：hidden；因此这个时候，只需要对要操作的元素的父元素的touchmove事件，做一个event.preventDefault()即可。

先实现非惯性滑动
-
这点功能主要在touchmove中操作：
1. 记录用户滑动距离，
2. 根据用户滑动距离改变元素transform： trnalate的值，

当我通过`window.getComputedStyle`获取container的相关值得时候，发现只能获取到一个变换矩阵的值，只好通过处理字符串的方式获取到translateY的值

其他的就很容易了


惯性滑动
-
先不所这个功能在哪个事件中实现，我要先解决如何判断非惯性滑动个惯性滑动的问题

先尝试通过用户滑动的事件来区分，这里的时间值得是：touchstart和touchend中的时间差。 暂时以100ms位中间值, 此时先不设置touchmove事件，只测试判断方法是否可行

这时候发现了一个问题，在浏览器中的惯性滚动事件，有两种情况： 第一种是用户直接快速划过，第二种是用户慢速滑动的结尾忽然快速滑动，也会触发惯性滚动，因此只根据start和end时间差来区分肯定是行不通了，应该是时间差和距离一起来区分。能和时间差与距离有关系的只有速度了，也就是说当速度达到一定数值的时候，就会触发惯性滚动。

先按照这个想法做下去， 那么如何计算速度，计算速度的时间段是一个很重要得问题， 如果只是计算start和end的时间差，就实现不了第二种的惯性滑动， 因此这个速度的时间段必须从move过程中获取: 通过计算两次move事件的间隔事件和距离来判断！！

